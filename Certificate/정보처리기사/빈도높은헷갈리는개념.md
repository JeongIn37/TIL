# **GoF(Gang of Four) 디자인 패턴**

## **생성 패턴 (5가지) :** 객체를 생성하는데 관련된 패턴들

- 추상 팩토리 **Abstract Factory Pattern :** 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
- 빌더 **Builder Pattern :** 작게 분리된 인스턴스를 건축하듯이 조합하여 객체 생성
- 팩토리 메소드 **Factory Method Pattern :** 객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화한 패턴
- 프로토타입 **Prototype Pattern :** 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 싱글톤 **Singleton Pattern :** 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할 수 는 없다.

## **구조 패턴 (7가지) :** 프로그램 구조에 관련된 패턴들

- 어댑터 **Adapter Pattern :** 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브리지 **Bridge Pattern :** 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 컴포지트 **Composite Pattern :** 여러 객체를 가진 복합 객체와 단일객체를 구분없이 다루고자 할 때 사용하는 패턴
- 데코레이터: 상속 사용 없이 객체 기능을 동적으로 확장해주는 패턴
- 퍼싸드: 서브 클래스들의 기능을 간편히 사용하도록 하는 패턴 (ex. 리모컨)
- 플라이웨이트: 공유해서 사용하여 메모리 절약하는 패턴
- 프록시: 접근이 어려운 객체를 연결하는 인터페이스 역할 수행

## **행동 패턴 (11가지) :** 반복적으로 사용되는 객체들의 상호작용을 패턴화해놓은 것들

# UML

## 구성요소

- 사물, 관계, 다이어그램

## 구조적, 정적 다이어그램

- 클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지

## 행위, 동적 다이어그램

- 유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 상호작용, 타이밍

# DFD

## 구성요소 PTSD

1. 프로세스(Process)
2. 자료 흐름(Data Flow)
3. 자료 저장소(Data Store)
4. 단말(Terminator)

# 럼바우의 객체지향 분석

1. 객체 모델링: 객체 다이어그램
2. 동적 모델링: 상태도(상태 다이어그램)
3. 기능 모델링: 자료 흐름도

# CASE 도구

소프트웨어 개발과정 자동화를 위한 도구

개발환경 구축 및 자동화

작업 과정 및 데이터 공유로 작업자 간의 커뮤니케이션 증대

## 주요기능

1. SW 라이프사이클 전 단계의 연결
2. 그래픽 지원
3. 다양한 소프트웨어 개발 모형 지원

# HIPO (Hierachy Input Process Output)

하향식 소프트웨어 개발을 위한 문서화 도구

차트 종류: 가시적 도표, 총체적 도표, 세부적 도표

기능과 자료의 의존 관계 동시에 표현 가능

보기 쉽고 이해 쉬움

# 객체지향 분석 방법론

## Coad와 Yourdon 방법

E-R 다이어그램을 사용한 객체 행위 모델링

## Booch 방법

미시적 개발 프로세스 + 거시적 개발 프로세스

## Jacobson 방법

유스케이스 강조

## Wirfs-Brocks 방법

분석과 설계 간의 구분 X

---

# 암호화 알고리즘

## 대칭키 (암호화키 = 복호화키)

## 종류

- 블록 암호화 방식 (한번에 하나의 데이터 블록 암호화)
    1. DES
    2. SEED
    3. AES
    4. ARIA
- 스트림 암호화 방식 (평문과 동일한 길이의 스트림 생성하여 비트 단위 암호화)
    1. LFSR
    2. RC4

### 특징

- 암호화/복호화 속도 빠름
- 알고리즘 단순
- 파일 크기 작음
- 사용자 증가에 따라 관리할 키의 수가 상대적으로 많음

## 비대칭키 (암호화키 ≠ 복호화키)

1. RSA(소인수분해)
2. EIGAMAI(이산대수)
3. ECC(타원곡선)

# 접근 통제 정책

## 신분 기반 정책(DAC)

주체나 그룹의 신분에 근거에 객체 접근 제한

## 규칙 기반 정책(MAC)

주체가 갖는 권한에 근거해 객체 접근 제한

## 역할 기반 정책(RBAC)

주체가 맡은 역할에 근거해 객체 접근 제한

# 스토리지

## DAS (Direct Attached Storage)

서버와 저장장치를 전용 케이블로 직접 연결

- 장점: 속도 빠름. 설치 운영 쉬움. 초기 구축 및 유지보수 저렴.
- 단점: 파일 공유 불가. 확작성 및 유연성 떨어짐

## NAS (Network Attached Storage)

서버와 저장장치를 네트워크를 통해 연결

- 장점: 장소에 구애 X. 확장성 및 유연성 우수.
- 단점: 접속 증가시 성능 저하

## SAN (Storage Area Network)

서버와 저장장치를 연결하는 전용 네트워크 별도 구성

- 장점: 파이버 채널 스위치로 네트워크 구성. 광케이블로 처리속도 빠름. 확장성, 유연성, 가용성 뛰어남.
- 단점: 설치 비용 비쌈

# 소프트웨어 개발 방법론

1. 구조적 방법론: 정형화된 분석 절차. 사용자 요구분석 파악. 문서화
2. 정보공학 방법론: 정보 시스템 개발을 위해 통합 적용하는 자료 중심
3. **객체 지향 방법론**: 현실 세계의 개체를 객체로 만들어 부품 조립하듯 구현
4. **컴포넌트 기반(CBD: Component Based Design)** **방법론**: 컴포넌트를 조합하여 하나의 애플리케이션 만듦.
    
    컴포넌트 및 소프트웨어 재사용 가능.
    
    확장성 우수. 개발 기간 단축으로 생산성 향상
    
5. **애자일 방법론**: 변화에 유연한 대응하도록 일정 주기 반복하며 개발
6. 제품 계열 방법론: 특정 제품에 적용하고 싶은 공통 기능 정의하며 개발. 임베디드에 주로 사용

# 비용 산정 기법

## 하향식 비용 산정 기법

1. 전문가 감정 기법: 두 명 이상의 전문가에게 비용 산정 의뢰
    
    개인적, 주관적일 수 있음
    
2. 델파이 기법: 전문가 감정 기법의 주관성 보완을 위해 한 명의 조정자와 여러 명의 전문가 의견 종합 산정

## 상향식 비용 산정 기법

1. LOC(원시 코드 라인 수) 기법
    
    : 코드 라인 수의 비관치, 낙관치, 기대치 측정 → 계산 문제
    
2. 개발 단계별 인원수
    
    : LOC 보완을 위한 기법
    
3. 수학적 산정 기법
    1. **COCOMO**
        
        소프트웨어 개발비 견적에 널리 통용. 보헴(Bohem) 제안
        
        같은 규모여도 성격에 따라 비용이 다르게 산정
        
        - Organic(조직형, 중소규모 소프트웨어. 5만라인 이하)
        - Semi-Detached(반분리형. 30만 라인 이하)
        - Embedded(내장형. 30만 라인 이상 대형 규모)
    2. Putnam
        
        주기 동안 사용될 노력의 분포 가정. 생명 주기 예측 모형
        
        Rayleigh-Norden 곡선의 노력 분포도 기초
        
        자동화 추정 도구: **SLIM**
        
    3. 기능점수(FP: Function-Point)
        
        요인 별로 가중치 부여. 합산하여 기능점수 산출.
        
        자동화 추정 도구: **ESTIMACS**
        

# 소프트웨어 개발 표준

## ISO/IEC 12207

표준 소프트웨어 생명 주기 프로세스

기본 / 조직 / 지원 생명 주기 프로세스

## CMM (Capability Maturity Model Integration, 능력 성숙도 통합 모델)

업무 능력 및 조직의 성숙도 평가

### 성숙도 5단계

1. 초기
2. 관리
3. 정의
4. 정량적 관리
5. 최적화

## SPICE (ISO/IEC 15504)

소프트웨어 프로세스 평가 및 개선하는 국제 표준

### 프로세스 수행 능력 단계

1. 불완전
2. 수행: 프로세스 수행. 목적 달성
3. 관리
4. 확립
5. 예측
6. 최적화

# 정보보안 3대 요소

1. 기밀성
2. 무결성
3. 가용성

# tripwire / stack guard

## tripwire

크래커가 침입하여 백도어를 만들거나 설정파일 변경시 분석하는 도구

### Stack Guard

오버플로우 상태 가정하여 프로그램 실행 중단하는 기술

# 라우팅 프로토콜

### RIP (Routing Information Protocol)

벨만포드 알고리즘을 이용해 최적 경로 설정하는 소규모 프로토콜

최대 홉 15로 제한

거리 벡터 프로토콜

### OSPF (Open Shortest Path First)

RIP 단점 개선. daijkstra 알고리즘 + Link Static 기반 대규모 프로토콜

### BGP (Border Gateway Protocol)

자치 시스템간의 라우팅 프로토콜. EGP의 단점 보완. 라우팅 테이블 교환

# 신기술

## 하드웨어

1. N-Screen: N개의 서로 다른 단말기에서 동일 컨텐츠 이용 가능
2. Memristor: memory + register 전원 공급이 끊어져도 다시 전원이 공급되면 이전 상태 복원
3. MEMS: 센서, 액추에이터 등 기계구조를 미세 가공 후 전기기계적 동작 가능하게 하는 초미세장치

## 데이터베이스

1. Hadoop: 오픈 소스 기반 분산 컴퓨팅 플랫폼. 일반 PC급에서 가상화된 대형 스토리지 형성

---

# IPv6

128비트. 인증성, 기밀성, 데이터 무결성 지원. 네트워크 기능 확장 용이. 품질 보장

- 유니캐스트, 멀티캐스트, 애니캐스트
    
    cf) IPv4: 유니캐스트, 멀티캐스트, 브로드캐스트
    

# 결합도: 내공외제스자

Bad(결합도 높음) → Good(결합도 낮음)

내용(Content) > 공통(Common) > 외부(External) > 제어(Control) > 스탬프(Stamp) > 자료(Data)

### (내)게 (공)(부)하라고 강요 말아요. (외)냐하면 (제)가 (스)트레스 받(자)나요.

# 응집도: 우논시절통순기

Bad(응집도 낮음) → Good(응집도 높음)

우연적 응집도 < 논리적 응집도 < 시간적 응집도 < 절차적 응집도 < 통신적(교환적) 응집도 < 순차적 응집도 < 기능적 응집도

# 교착상태

## 필요충분 조건

- 상호 배제, 점유와 대기, 환형 대기, 비선점

## 교착 상태 해결법

### Detection(탐지)

교착상태 발생 허용. 발생 시 원인 규명하여 해결.

- 자원할당 그래프

### Avoidance(회피)

교착상태 가능성 배제하지 않고 피해나가는 방법

- 은행원 알고리즘

### Recovery(복구)

교착상태 발견 후 현황대기 배제 or 자원 중단하는 메모리 할당 기법

- 선점, 프로세스 중지(희생자 선택)

### Prevention(예방)

교착상태의 필요조건을 부정함으로써 교착상태가 발생하지 않도록 미리 예방

- 환형 대기, 점유와 대기, 상호배체 4가지 부정

# TCP/IP

## TCP

OSI 7 계층의 전송 계층(4)에 해당

신뢰성 있는 연결형 서비스 제공

- 순서 제어, 오류 제어, 흐름 제어 기능. 스트림 전송 기능

## IP

OSI 7 계층의 네트워크 계층(3)에 해당

데이터 그램을 기반으로 하는 비연결형 서비스 제공

- 경로 선택 기능(라우팅) 제공


# HRN (Highest Response-ratio Next)

SJF 기법 가뭄현상 보완 방식. 우선 순위 계산식의 수치가 가장 높은 것부터 낮은 순으로 우선순위 부여

> 계산식: (대기시간 + 서비스시간) / 서비스 시간
> 


---

# 전위식 / 후위식 / 중위식

- 중위식: 우리가 일반적으로 아는 식
- 전위식: 연산자가 앞에 옴
- 후위식: 연산자가 뒤에 옴

# 트리 순회

- Inorder(중위): 트리 끝(좌측 단말 노드)에서부터 올라옴 (루트 or 더 올라갈 노드가 없으면) 다음 단말 노드로 이동
- Preorder(전위): 루트 노드부터 단말 노드까지 내려감 더 내려갈 수 없으면 다시 올라와서 또 내려감
- Postorder(후위): 상위 노드에 가기 전 모든 단말 노드를 읽고 올라감. 한 번 올라가면 안 내려온다는 생각으로 하면 됨

# 릴레이션 정규화

- 비정규 릴레이션
    
    → 도메인이 원자값
    
- 1NF
    
    모든 속성의 도메인이 원자값으로만 구성
    
    → 부분적 함수 종속 제거
    
- 2NF
    
    1NF + 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속됨
    
    → 이행적 함수 종속 제거
    
- 3NF
    
    2NF + 기본키가 아닌 모든 속성이 이행적 함수 종속이 되지 않음
    
    → 결정자이면서 후보키가 아닌 것 제거
    
- BCNF
    
    → 다치 종속
    
- 4NF
    
    BCNF + 함수 종속이 아닌 다치 종속 제거됨
    
    → 조인 종속성 이용
    
- 5NF
    
    4NF + 조인 종속 제거됨
    

## 정규화

1 → 2 → 3 → BCNF → 4 → 5

도 부 이 결 다 조

# 알고리즘 소요 시간

O(1) → 해시 함수

O(logN) → 이진 탐색

O(N) → 순차 탐색

O(NlogN) → 퀵 정렬, 병합 정렬

O(N^2) → 버블 정렬, 삽입 정렬, 선택 정렬

- 정렬된 데이터의 경우, 버블 정렬과 삽입 정렬을 O(N)이 될 수 있음

# 블랙박스 / 화이트박스 테스트

## 블랙박스 테스트

작동원리를 모르는 상태에서 ‘동작' 검사 → 사용자 관점 테스트

- 경계값 분석
- 기능 테스트
- 프로그램 고려 X

## 화이트박스 테스트

‘내부 소스코드' 테스트 → 개발자 관점 테스트

- 문장 검증: 모든 문장이 최소 한 번씩 수회되는 검증 기준
- 선택 검증: 선택하는 부분만 검증
- 경로 검증: 수행 가능한 모든 경로 검증
- 조건 검증: 문장 내 조건식 조사 기준

# 스택을 이용한 연산

- 재귀호출
- 후위표현 연산
- 깊이 우선 탐색

# 큐를 이용한 연산

- 선택 정렬

# 데이터베이스 분할 기법

## 수평 분할

하나의 테이블의 각 행을 다른 테이블에 분산시키는 것

1. 라운드-로빈
    
    : 파티션에 행의 고른 분포를 원할 때 사용. 해시분할과 달리 칼럼 명시할 필요 X. 라운드 로빈 분할로 회전하며 새로운 행이 파티션에 할당. 테이블에 기본키 반드시 필요 X
    
2. 범위 분할
3. 해시 분할
    
    : 병렬 데이터베이스 환경 중 수평분할에 활용
    

# KEY(키)

1. 슈퍼키: 유일성을 만족하는 속성 또는 속성들의 집합 (최소성 만족 X)
2. 후보키: 유일성 + 최소성을 만족하는 속성 또는 속성들의 집합
3. 대체키: 기본키로 선택되지 못한 후보키
4. 외래키: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
5. 기본키: 후보키 중 특별히 선정된 메인 키. 특정 튜플을 유일하게 구별하는 속성. 중복 X. NULL X

# DDL / DML / DCL

## DDL (정의)

1. CREATE: 정의
2. ALTER: 변경
3. DROP: 삭제

## DML (조작)

1. SELECT: 검색
2. INSERT: 삽입
3. DELETE: 삭제
4. UPDATE: 갱신

## DCL (제어)

1. COMMIT: 완료
2. ROLLBACK: 되돌림
3. GRANT: 권한부여
4. REVOKE: 권한취소

# 충돌

## Collision Domain: 충돌 도메인

충돌 발생을 검출할 수 있는 브리지 간 혹은 다른 계층 간의 이더넷 세그먼트 범위

## CSMA/CD: 충돌 감지

이더넷에서 각 단말이 전송 공유 매체에 규칙있게 접근하기 위한 매체 엑세스 제어 방식

## CSMA/CA: 충돌 방지

무선 랜에서 데이터 전송시 매체가 비었음을 확인 후 충돌을 피하기 위해 임의 시간동안 기다리고 데이터 전송. 네트워크에 데이터의 전송이 없더라도 동시 전송에 의한 충돌에 대비해 확인 신호 전송

# SSTF (Shortest Seek Time First)

현재 헤드위치에서 가장 가까운 것부터 탐색

현 위치로부터의 거리(절댓값)을 구하여 가장 작은 것으로 이동 → 반복

# 포인터

a

&a : a의 주소값

*a : a가 가리키고 있는 주소에 저장된 값 

*&a: *(포인터 a의 주소값) = 포인터 a의 주소가 가리키고 있는 주소에 저장된 값

# 페이징

### 페이징 크기가 작은 경우

1. 더 많은 페이징 사상 테이블 필요
2. 내부 단편화 감소
3. 페이지의 집합 효율적 운영 가능
4. 기억장치의 효율 좋음
5. 총 입출력 시간 증가

### 페이징 크기가 클 경우

1. 주 기억장치 공간 절약
2. 참조되는 정보와 무관한 양의 정보가 주 기억장치에 남음
3. 테이블이 복잡해지지 않아 관리 용이


# 연산자 우선 순위

높음 → 낮음

1. 증감 연산자(++, --)
2. 산술 연산자(* / %)
3. 산술 연산자(+ -)
4. 시프트 연산자(>>, <<)
5. 관계 연산자 (<, >, ≤, ≥)
6. 관계 연산자 (==, !=)
7. 비트 연산자 (& ^ | )
8. 논리 연산자(&&, ||)
9. 조건 연산자(?:)
10. 대입 연산자(= += *= /= %= <<= >>=)
11. 순서 연산자(.)